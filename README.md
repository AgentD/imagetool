# About

The main idea is to have a tool for generating disk images from a textual
description.

On the one hand, the descritpion provides the layout of the image (partition
layout, UBI or LVM volumes, etc...) and what filesystems to install on the
partitions in a way that can be nested arbitrarily deep.

On the other hand, the description provides a way to pack files into the
filesystems (e.g. data from a tarball, a directory or a manual listing).

## Motivation

Let's say, you are playing around with an embedded board that boots of
an SD card. You want to automatically create a customized image where most of
the filesystem is inside a SquashFS, which is itself stored inside a FAT32 boot
partition, together with the kernel and bootloader configuration files. The home
directories (and possibly some other muteable state) are supposed to be stored
on an extra partition with a mutable filesystem. The entire mount setup itself
is done by an initrd with a custom script inside it.

You already have the entire rootfs in a tarball, generated by something
like Yocto, `mmdebstrap` or another bootstrapping tool.

So now you bust out a plethorea of different programs (`parted`, `mkfs*`,
etc...) to create the image, loop mount it so you can populate the partitions
and so on and wrap all of that into a shell script.

Because the shell script loop mounts stuff, it needs to be run as root. Or you
discover that various `mkfs*` tools have ways of pre-populating the filesystem
that are of course different between tools and you still need temporary files
and some `dd` magic to make it work with partitions. If the tools you use can
only pack files from a directory, you may need to unpack the tarball and do
some fakeroot magic.

Imagine, instead, you could simply describe the partition layout in a
configuration file as follows:

	{
		"type": "msdos",
		"align": "1M",

		"partitions": [
			{
				"type": "primary",
				"boot": true,

				"filesystem": {
					"type": "fat32",
					"name": "bootvolume",

					"volumefiles": [
						{
							"path": "initrd.xz",

							"filesystem": {
								"type": "initrd",
								"name": "kernelinitrd",

								"compression": "xz"
							}
						}, {
							"path": "rootfs.sqfs",

							"filesystem": {
								"type": "squashfs",
								"name": "rootfs"
							}
						}
					]
				}
			}, {
				"type": "primary",

				"filesystem": {
					"type": "ext4",
					"name": "homedirs"
				}
			}
		]
	}

We have an dos style partition table with 2 partitions, a FAT32 one and an ext4
one. Note that the FAT32 partition has a list of `volumefiles`, which is
basically a way to create special files that can then function in the same way
as a partition, with a nested filesystem on their own.

Each filesystem has a name attached that we use in a seperate  configuration
file to populate the filesystems:

	{
		"type": "mountgroup",
		"name": "main",

		"mountpoints": [
			{ "vdir": "/", "target": "rootfs" },
			{ "vdir": "/home", "target": "homedirs" },
			{ "vdir": "/boot", "target": "bootvolume" }
		],

		"datasource": [
			{
				"type": "tar",
				"path": "rootfs.tar.gz"
			}
		]
	}, {
		"type": "mountgroup",
		"name": "initrd",

		"mountpoints": [
			{ "vdir": "/", "target": "kernelinitrd" }
		],

		"datasource": [
			{
				"type": "listing",
				"filesource": "."

				"listing": [
					"dir dev 0755 0 0",
					"dir lib 0755 0 0",
					"dir bin 0755 0 0",
					"dir sys 0755 0 0",
					"dir proc 0755 0 0",
					"dir newroot 0755 0 0",
					"dir images 0755 0 0",
					"slink sbin 0777 0 0 bin",
					"nod dev/console 600 0 0 c 5 1",
					"file init 0755 0 0 initrd.sh"
				]
			}, {
				"type": "filter",

				"filterInclude": [
					"bin/busybox",
					"lib/ld*.so*",
					"lib/libc*.so*"
				],

				"datasource": [
					{
						"type": "tar",
						"path": "rootfs.tar.gz"
					}
				]
			}
		]
	}

This file completely describes how to split the contents of the tarball up into
the different filesystems on different partitions. For the initrd, a listing
similar to `geninitramfs` is used, in combination with a filter that splits out
busybox and friends from the rootfs tarball.

Finally, a single program is run to generate the image from the description:

	$ mkimage -l layout.json -p data.json -O sdcard.img


## Plans

### Near term future

Input data source:
 - possibly compressed tarballs
 - manual, `geninitramfs` style listing
 - shell glob filter with other, nested sources

Output formats:
 - Raw (i.e. no headers)
 - MBR & GPT partition tables

Filesystems:
 - SquashFS (through libsquashfs)
 - FAT32
 - possibly compressed cpio
 - possibly compressed tar
 - zip

### Medium term future

Output formats:
 - LVM, luks
 - UBI

Filesystems:
 - EXT4
 - UBIFS

Figure out how to integerate bootloaders into the tooling.
